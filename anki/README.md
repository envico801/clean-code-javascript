# RCCJ - Clean code javascript - ryan mcdermott

## Questions

| ID | File name / path | Part | Chapter |
| --- | --- | --- | --- |
| **-** | **Fundamentals** | **1** | **-** |
| **-** | **Fundamentals > Variables** | **1** | **1** |
| [1](#id1) | [Use meaningful and pronounceable variable](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%201%20-%20Variables/1%20-%20Use%20meaningful%20and%20pronounceable%20variable.md) | 1 | 1 |
| [2](#id2) | [Use the same vocabulary for the same type](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%201%20-%20Variables/2%20-%20Use%20the%20same%20vocabulary%20for%20the%20same%20type.md) | 1 | 1 |
| [3](#id3) | [Use searchable names we will read more cod](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%201%20-%20Variables/3%20-%20Use%20searchable%20names%20we%20will%20read%20more%20cod.md) | 1 | 1 |
| [4](#id4) | [Use explanatory variables break down compl](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%201%20-%20Variables/4%20-%20Use%20explanatory%20variables%20break%20down%20compl.md) | 1 | 1 |
| [5](#id5) | [Avoid mental mapping don t force readers t](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%201%20-%20Variables/5%20-%20Avoid%20mental%20mapping%20don%20t%20force%20readers%20t.md) | 1 | 1 |
| [6](#id6) | [Don t add unneeded context when the contex](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%201%20-%20Variables/6%20-%20Don%20t%20add%20unneeded%20context%20when%20the%20contex.md) | 1 | 1 |
| [7](#id7) | [Use default parameters instead of short-ci](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%201%20-%20Variables/7%20-%20Use%20default%20parameters%20instead%20of%20short-ci.md) | 1 | 1 |
| **-** | **Fundamentals > Functions** | **1** | **2** |
| [8](#id8) | [Function arguments 2 or fewer ideally ha](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/8%20-%20Function%20arguments%202%20or%20fewer%20ideally%20ha.md) | 1 | 2 |
| [9](#id9) | [Functions should do one thing a fundamenta](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/9%20-%20Functions%20should%20do%20one%20thing%20a%20fundamenta.md) | 1 | 2 |
| [10](#id10) | [Function names should say what they do fun](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/10%20-%20Function%20names%20should%20say%20what%20they%20do%20fun.md) | 1 | 2 |
| [11](#id11) | [Functions should only be one level of abst](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/11%20-%20Functions%20should%20only%20be%20one%20level%20of%20abst.md) | 1 | 2 |
| [12](#id12) | [Remove duplicate code code duplication is](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/12%20-%20Remove%20duplicate%20code%20code%20duplication%20is.md) | 1 | 2 |
| [13](#id13) | [Set default objects with object assign whe](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/13%20-%20Set%20default%20objects%20with%20object%20assign%20whe.md) | 1 | 2 |
| [14](#id14) | [Don t use flags as function parameters boo](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/14%20-%20Don%20t%20use%20flags%20as%20function%20parameters%20boo.md) | 1 | 2 |
| [15](#id15) | [Avoid side effects part 1 side effects a](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/15%20-%20Avoid%20side%20effects%20part%201%20side%20effects%20a.md) | 1 | 2 |
| [16](#id16) | [Avoid side effects part 2 mutable data s](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/16%20-%20Avoid%20side%20effects%20part%202%20mutable%20data%20s.md) | 1 | 2 |
| [17](#id17) | [Don t write to global functions extending](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/17%20-%20Don%20t%20write%20to%20global%20functions%20extending.md) | 1 | 2 |
| [18](#id18) | [Favor functional programming over imperati](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/18%20-%20Favor%20functional%20programming%20over%20imperati.md) | 1 | 2 |
| [19](#id19) | [Encapsulate conditionals complex condition](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/19%20-%20Encapsulate%20conditionals%20complex%20condition.md) | 1 | 2 |
| [20](#id20) | [Avoid negative conditionals negative condi](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/20%20-%20Avoid%20negative%20conditionals%20negative%20condi.md) | 1 | 2 |
| [21](#id21) | [Avoid conditionals understanding why and h](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/21%20-%20Avoid%20conditionals%20understanding%20why%20and%20h.md) | 1 | 2 |
| [22](#id22) | [Avoid type-checking part 1 type checking](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/22%20-%20Avoid%20type-checking%20part%201%20type%20checking.md) | 1 | 2 |
| [23](#id23) | [Avoid type-checking part 2 type checking](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/23%20-%20Avoid%20type-checking%20part%202%20type%20checking.md) | 1 | 2 |
| [24](#id24) | [Don t over-optimize premature optimization](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/24%20-%20Don%20t%20over-optimize%20premature%20optimization.md) | 1 | 2 |
| [25](#id25) | [Remove dead code dead code is code that s](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%202%20-%20Functions/25%20-%20Remove%20dead%20code%20dead%20code%20is%20code%20that%20s.md) | 1 | 2 |
| **-** | **Fundamentals > Objects and Data Structures** | **1** | **3** |
| [26](#id26) | [Use getters and setters getters and setter](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%203%20-%20Objects%20and%20Data%20Structures/26%20-%20Use%20getters%20and%20setters%20getters%20and%20setter.md) | 1 | 3 |
| [27](#id27) | [Make objects have private members privacy](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%203%20-%20Objects%20and%20Data%20Structures/27%20-%20Make%20objects%20have%20private%20members%20privacy.md) | 1 | 3 |
| **-** | **Fundamentals > Classes** | **1** | **4** |
| [28](#id28) | [Prefer es2015-es6 classes over es5 plain f](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%204%20-%20Classes/28%20-%20Prefer%20es2015-es6%20classes%20over%20es5%20plain%20f.md) | 1 | 4 |
| [29](#id29) | [Use method chaining method chaining is a p](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%204%20-%20Classes/29%20-%20Use%20method%20chaining%20method%20chaining%20is%20a%20p.md) | 1 | 4 |
| [30](#id30) | [Prefer composition to inheritance composit](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%204%20-%20Classes/30%20-%20Prefer%20composition%20to%20inheritance%20composit.md) | 1 | 4 |
| **-** | **Fundamentals > SOLID** | **1** | **5** |
| [31](#id31) | [Single responsibility principle srp the](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%205%20-%20SOLID/31%20-%20Single%20responsibility%20principle%20srp%20the.md) | 1 | 5 |
| [32](#id32) | [Open-closed principle ocp the open-close](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%205%20-%20SOLID/32%20-%20Open-closed%20principle%20ocp%20the%20open-close.md) | 1 | 5 |
| [33](#id33) | [Liskov substitution principle lsp the li](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%205%20-%20SOLID/33%20-%20Liskov%20substitution%20principle%20lsp%20the%20li.md) | 1 | 5 |
| [34](#id34) | [Interface segregation principle isp the](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%205%20-%20SOLID/34%20-%20Interface%20segregation%20principle%20isp%20the.md) | 1 | 5 |
| [35](#id35) | [Dependency inversion principle dip the d](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%205%20-%20SOLID/35%20-%20Dependency%20inversion%20principle%20dip%20the%20d.md) | 1 | 5 |
| **-** | **Fundamentals > Testing** | **1** | **6** |
| [36](#id36) | [Single concept per test tests should be cl](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%206%20-%20Testing/36%20-%20Single%20concept%20per%20test%20tests%20should%20be%20cl.md) | 1 | 6 |
| **-** | **Fundamentals > Concurrency** | **1** | **7** |
| [37](#id37) | [Use promises not callbacks promises provi](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%207%20-%20Concurrency/37%20-%20Use%20promises%20not%20callbacks%20promises%20provi.md) | 1 | 7 |
| [38](#id38) | [Async-await are even cleaner than promises](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%207%20-%20Concurrency/38%20-%20Async-await%20are%20even%20cleaner%20than%20promises.md) | 1 | 7 |
| **-** | **Fundamentals > Error Handling** | **1** | **8** |
| [39](#id39) | [Don t ignore caught errors proper error ha](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%208%20-%20Error%20Handling/39%20-%20Don%20t%20ignore%20caught%20errors%20proper%20error%20ha.md) | 1 | 8 |
| [40](#id40) | [Don t ignore rejected promises proper hand](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%208%20-%20Error%20Handling/40%20-%20Don%20t%20ignore%20rejected%20promises%20proper%20hand.md) | 1 | 8 |
| **-** | **Fundamentals > Formatting** | **1** | **9** |
| [41](#id41) | [Use consistent capitalization consistent c](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%209%20-%20Formatting/41%20-%20Use%20consistent%20capitalization%20consistent%20c.md) | 1 | 9 |
| [42](#id42) | [Function callers and callees should be clo](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%209%20-%20Formatting/42%20-%20Function%20callers%20and%20callees%20should%20be%20clo.md) | 1 | 9 |
| **-** | **Fundamentals > Comments** | **1** | **10** |
| [43](#id43) | [Only comment things that have business log](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%2010%20-%20Comments/43%20-%20Only%20comment%20things%20that%20have%20business%20log.md) | 1 | 10 |
| [44](#id44) | [Don t leave commented out code in your cod](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%2010%20-%20Comments/44%20-%20Don%20t%20leave%20commented%20out%20code%20in%20your%20cod.md) | 1 | 10 |
| [45](#id45) | [Don t have journal comments journal commen](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%2010%20-%20Comments/45%20-%20Don%20t%20have%20journal%20comments%20journal%20commen.md) | 1 | 10 |
| [46](#id46) | [Avoid positional markers positional marker](./RCCJ%20-%20Clean%20code%20javascript%20-%20ryan%20mcdermott/Part%20I%20-%20Fundamentals/Chapter%2010%20-%20Comments/46%20-%20Avoid%20positional%20markers%20positional%20marker.md) | 1 | 10 |

### Part I - Fundamentals

#### Chapter 1 - **Variables**

Q:: =============================================  

##### Use meaningful and pronounceable variable names

When naming variables, use clear, descriptive names that explain their purpose. Avoid abbreviations and cryptic shorthand that might confuse other developers.

**Bad:**
```javascript
const yyyymmdstr = moment().format("YYYY/MM/DD");
```

###### ID1

A:: =============================================  
The variable name should clearly indicate that we're working with a date. Using 'currentDate' immediately tells other developers the purpose of this variable.

**Good:**
```javascript
const currentDate = moment().format("YYYY/MM/DD");
```

Q:: =============================================  

##### Use the same vocabulary for the same type of variable

When referring to the same type of data or operation, maintain consistency in your naming conventions throughout your codebase. This reduces cognitive load and makes the code more predictable.

**Bad:**
```javascript
getUserInfo();
getClientData();
getCustomerRecord();
```

###### ID2

A:: =============================================  
Choose one term and stick with it. If you decide to use 'user', use it consistently throughout your application instead of mixing terms like 'client' or 'customer' for the same concept.

**Good:**
```javascript
getUser();
```

Q:: =============================================  

##### Use searchable names

We will read more code than we will ever write. It's important that the code we do write is readable and searchable. By _not_ naming variables that end up being meaningful for understanding our program, we hurt our readers. Make your names searchable. Tools like [buddy.js](https://github.com/danielstjules/buddy.js) and [ESLint](https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md) can help identify unnamed constants.

**Bad:**
```javascript
// What the heck is 86400000 for?
setTimeout(blastOff, 86400000);
```

###### ID3

A:: =============================================  
Magic numbers (unexplained numerical values) should be converted into named constants that clearly explain their purpose. This makes code more maintainable and helps other developers understand the intent immediately.

**Good:**
```javascript
// Declare them as capitalized named constants.
const MILLISECONDS_PER_DAY = 60 * 60 * 24 * 1000; //86400000;

setTimeout(blastOff, MILLISECONDS_PER_DAY);
```

Q:: =============================================  

##### Use explanatory variables

Break down complex expressions into smaller, well-named parts. This makes the code easier to understand and maintain by making each step's purpose clear.

**Bad:**
```javascript
const address = "One Infinite Loop, Cupertino 95014";
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
saveCityZipCode(address.match(cityZipCodeRegex)[1], address.match(cityZipCodeRegex)[2]);
```

###### ID4

A:: =============================================  
Using destructuring and intermediate variables makes complex operations more readable. Each step becomes self-documenting through clear variable names.

**Good:**
```javascript
const address = "One Infinite Loop, Cupertino 95014";
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
const [_, city, zipCode] = address.match(cityZipCodeRegex) || [];
saveCityZipCode(city, zipCode);
```

Q:: =============================================  

##### Avoid Mental Mapping

Don't force readers to translate between different contexts. Using single-letter variables or abbreviated names requires the reader to mentally map these to their actual meaning.

**Bad:**
```javascript
const locations = ["Austin", "New York", "San Francisco"];
locations.forEach((l) => {
  doStuff();
  doSomeOtherStuff();
  // ...
  // ...
  // ...
  // Wait, what is `l` for again?
  dispatch(l);
});
```

###### ID5

A:: =============================================  
Use complete, descriptive variable names that don't require the reader to remember what abbreviations stand for. This makes code immediately understandable without having to scroll up to check variable meanings.

**Good:**
```javascript
const locations = ["Austin", "New York", "San Francisco"];
locations.forEach((location) => {
  doStuff();
  doSomeOtherStuff();
  // ...
  // ...
  // ...
  dispatch(location);
});
```

Q:: =============================================  

##### Don't add unneeded context

When the context is already clear from the class or object name, don't repeat it in the property names. This creates unnecessary verbosity and redundancy.

**Bad:**
```javascript
const Car = {
  carMake: "Honda",
  carModel: "Accord",
  carColor: "Blue",
};

function paintCar(car, color) {
  car.carColor = color;
}
```

###### ID6

A:: =============================================  
Remove redundant context when the parent object/class name already provides it. This makes the code more concise and easier to read while maintaining clarity.

**Good:**
```javascript
const Car = {
  make: "Honda",
  model: "Accord",
  color: "Blue",
};

function paintCar(car, color) {
  car.color = color;
}
```

Q:: =============================================  

##### Use default parameters instead of short-circuiting or conditionals

Default parameters provide a cleaner way to handle missing values in function parameters. They make the intended default value explicit in the function signature.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#use-default-parameters-instead-of-short-circuiting-or-conditionals](https://github.com/ryanmcdermott/clean-code-javascript#use-default-parameters-instead-of-short-circuiting-or-conditionals)

**Bad:**
```javascript
function createMicrobrewery(name) {
  const breweryName = name || "Hipster Brew Co.";
  // ...
}
```

###### ID7

A:: =============================================  
ES6 default parameters make the code more intentional and clearer. They only trigger when the parameter is `undefined`, providing more predictable behavior than logical OR operations.

**Good:**
```javascript
function createMicrobrewery(name = "Hipster Brew Co.") {
  // ...
}
```

#### Chapter 2 - **Functions**

Q:: =============================================  

##### Function arguments (2 or fewer ideally)

Having too many function parameters makes your code harder to test and maintain. Each additional parameter exponentially increases the number of test cases needed.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#function-arguments-2-or-fewer-ideally](https://github.com/ryanmcdermott/clean-code-javascript#function-arguments-2-or-fewer-ideally)

**Bad:**
```javascript
function createMenu(title, body, buttonText, cancellable) {
  // ...
}

createMenu("Foo", "Bar", "Baz", true);
```

###### ID8

A:: =============================================  
Use object destructuring when you need multiple parameters. This makes the function call more readable and allows for optional parameters without maintaining a specific order.

**Good:**
```javascript
function createMenu({ title, body, buttonText, cancellable }) {
  // ...
}

createMenu({
  title: "Foo",
  body: "Bar",
  buttonText: "Baz",
  cancellable: true,
});
```

Q:: =============================================  

##### Functions should do one thing

A fundamental principle of clean code is that functions should have a single responsibility. This makes them easier to understand, test, and maintain.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#functions-should-do-one-thing](https://github.com/ryanmcdermott/clean-code-javascript#functions-should-do-one-thing)

**Bad:**
```javascript
function emailClients(clients) {
  clients.forEach((client) => {
    const clientRecord = database.lookup(client);
    if (clientRecord.isActive()) {
      email(client);
    }
  });
}
```

###### ID9

A:: =============================================  
Break down complex functions into smaller, focused functions that each do one thing. This improves code reusability and makes the code's intent clearer.

**Good:**
```javascript
function emailActiveClients(clients) {
  clients.filter(isActiveClient).forEach(email);
}

function isActiveClient(client) {
  const clientRecord = database.lookup(client);
  return clientRecord.isActive();
}
```

Q:: =============================================  

##### Function names should say what they do

Function names should be verbs that clearly describe the action being performed. Avoid vague or ambiguous names that don't convey the function's purpose.

**Bad:**
```javascript
function addToDate(date, month) {
  // ...
}

const date = new Date();

// It's hard to tell from the function name what is added
addToDate(date, 1);
```

###### ID10

A:: =============================================  
Use specific, action-oriented function names that clearly describe what the function does. The name should make it obvious what parameters are expected and what the function will do with them.

**Good:**
```javascript
function addMonthToDate(month, date) {
  // ...
}

const date = new Date();
addMonthToDate(1, date);
```

Q:: =============================================  

##### Functions should only be one level of abstraction

Each function should work at a single level of abstraction. This means all operations within the function should be at a similar conceptual level, making the code easier to understand and maintain.

**Bad:**
```javascript
function parseBetterJSAlternative(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(" ");
  const tokens = [];
  REGEXES.forEach((REGEX) => {
    statements.forEach((statement) => {
      // ...
    });
  });

  const ast = [];
  tokens.forEach((token) => {
    // lex...
  });

  ast.forEach((node) => {
    // parse...
  });
}
```

###### ID11

A:: =============================================  
Break down complex functions into smaller, focused functions where each function handles one level of abstraction. This makes the code more readable and maintainable by separating concerns.

**Good:**
```javascript
function parseBetterJSAlternative(code) {
  const tokens = tokenize(code);
  const syntaxTree = parse(tokens);
  syntaxTree.forEach((node) => {
    // parse...
  });
}

function tokenize(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(" ");
  const tokens = [];
  REGEXES.forEach((REGEX) => {
    statements.forEach((statement) => {
      tokens.push(/* ... */);
    });
  });

  return tokens;
}

function parse(tokens) {
  const syntaxTree = [];
  tokens.forEach((token) => {
    syntaxTree.push(/* ... */);
  });

  return syntaxTree;
}
```

Q:: =============================================  

##### Remove duplicate code

Code duplication is one of the biggest enemies of maintainable software. When code is duplicated, changes need to be made in multiple places, increasing the chance of errors and making maintenance more difficult.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#remove-duplicate-code](https://github.com/ryanmcdermott/clean-code-javascript#remove-duplicate-code)

**Bad:**
```javascript
function showDeveloperList(developers) {
  developers.forEach((developer) => {
    const expectedSalary = developer.calculateExpectedSalary();
    const experience = developer.getExperience();
    const githubLink = developer.getGithubLink();
    const data = {
      expectedSalary,
      experience,
      githubLink,
    };

    render(data);
  });
}

function showManagerList(managers) {
  managers.forEach((manager) => {
    const expectedSalary = manager.calculateExpectedSalary();
    const experience = manager.getExperience();
    const portfolio = manager.getMBAProjects();
    const data = {
      expectedSalary,
      experience,
      portfolio,
    };

    render(data);
  });
}
```

###### ID12

A:: =============================================  
Create abstractions that handle the common functionality while accommodating differences through polymorphism or conditional logic. This reduces code duplication and makes the codebase easier to maintain.

**Good:**
```javascript
function showEmployeeList(employees) {
  employees.forEach((employee) => {
    const expectedSalary = employee.calculateExpectedSalary();
    const experience = employee.getExperience();

    const data = {
      expectedSalary,
      experience,
    };

    switch (employee.type) {
      case "manager":
        data.portfolio = employee.getMBAProjects();
        break;
      case "developer":
        data.githubLink = employee.getGithubLink();
        break;
    }

    render(data);
  });
}
```

Q:: =============================================  

##### Set default objects with Object.assign

When working with objects that need default values, using Object.assign or the spread operator provides a cleaner and more maintainable way to set default properties compared to manual property assignments.

**Bad:**
```javascript
const menuConfig = {
  title: null,
  body: "Bar",
  buttonText: null,
  cancellable: true,
};

function createMenu(config) {
  config.title = config.title || "Foo";
  config.body = config.body || "Bar";
  config.buttonText = config.buttonText || "Baz";
  config.cancellable = config.cancellable !== undefined ? config.cancellable : true;
}

createMenu(menuConfig);
```

###### ID13

A:: =============================================  
Use Object.assign to create a new object that combines default values with provided configuration. This approach is more declarative and prevents mutation of the original config object.

**Good:**
```javascript
const menuConfig = {
  title: "Order",
  // User did not include 'body' key
  buttonText: "Send",
  cancellable: true,
};

function createMenu(config) {
  let finalConfig = Object.assign(
    {
      title: "Foo",
      body: "Bar",
      buttonText: "Baz",
      cancellable: true,
    },
    config,
  );
  return finalConfig;
  // config now equals: {title: "Order", body: "Bar", buttonText: "Send", cancellable: true}
  // ...
}

createMenu(menuConfig);
```

Q:: =============================================  

##### Don't use flags as function parameters

Boolean flags in function parameters often indicate that a function is doing too much. When a function's behavior changes based on a boolean parameter, it's violating the Single Responsibility Principle.

**Bad:**
```javascript
function createFile(name, temp) {
  if (temp) {
    fs.create(`./temp/${name}`);
  } else {
    fs.create(name);
  }
}
```

###### ID14

A:: =============================================  
Split the function into two separate functions, each with a clear, single purpose. This makes the code's intent clearer and follows the Single Responsibility Principle.

**Good:**
```javascript
function createFile(name) {
  fs.create(name);
}

function createTempFile(name) {
  createFile(`./temp/${name}`);
}
```

Q:: =============================================  

##### Avoid Side Effects (part 1)

Side effects are changes that a function makes to any state outside its own scope. These can include modifying global variables, changing input parameters, or affecting the environment. They make code harder to test and can lead to unexpected bugs.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#avoid-side-effects-part-1](https://github.com/ryanmcdermott/clean-code-javascript#avoid-side-effects-part-1)

**Bad:**
```javascript
// Global variable referenced by following function.
// If we had another function that used this name, now it'd be an array and it could break it.
let name = "Ryan McDermott";

function splitIntoFirstAndLastName() {
  name = name.split(" ");
}

splitIntoFirstAndLastName();

console.log(name); // ['Ryan', 'McDermott'];
```

###### ID15

A:: =============================================  
Write pure functions that take inputs and return outputs without modifying external state. This makes the code more predictable and easier to test.

**Good:**
```javascript
function splitIntoFirstAndLastName(name) {
  return name.split(" ");
}

const name = "Ryan McDermott";
const newName = splitIntoFirstAndLastName(name);

console.log(name); // 'Ryan McDermott';
console.log(newName); // ['Ryan', 'McDermott'];
```

Q:: =============================================  

##### Avoid Side Effects (part 2)

Mutable data structures can lead to unintended side effects when shared across different parts of your application. When modifying objects or arrays that are passed as parameters, you risk affecting code elsewhere that uses those same references.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#avoid-side-effects-part-2](https://github.com/ryanmcdermott/clean-code-javascript#avoid-side-effects-part-2)

**Bad:**
```javascript
const addItemToCart = (cart, item) => {
  cart.push({ item, date: Date.now() });
};
```

###### ID16

A:: =============================================  
Instead of modifying input parameters, create and return new objects/arrays. This immutable approach helps prevent bugs and makes code behavior more predictable.

**Good:**
```javascript
const addItemToCart = (cart, item) => {
  return [...cart, { item, date: Date.now() }];
};
```

Q:: =============================================  

##### Don't write to global functions

Extending built-in objects through their prototypes (like Array, String, etc.) can lead to naming conflicts and unexpected behavior in your application, especially when multiple libraries are involved.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#dont-write-to-global-functions](https://github.com/ryanmcdermott/clean-code-javascript#dont-write-to-global-functions)

**Bad:**
```javascript
Array.prototype.diff = function diff(comparisonArray) {
  const hash = new Set(comparisonArray);
  return this.filter((elem) => !hash.has(elem));
};
```

###### ID17

A:: =============================================  
Use classes and inheritance to extend functionality instead of modifying global prototypes. This provides a cleaner, more maintainable way to add custom functionality.

**Good:**
```javascript
class SuperArray extends Array {
  diff(comparisonArray) {
    const hash = new Set(comparisonArray);
    return this.filter((elem) => !hash.has(elem));
  }
}
```

Q:: =============================================  

##### Favor functional programming over imperative programming

Functional programming leads to more predictable code by avoiding state changes and side effects. It focuses on what should be computed rather than how it should be computed.

**Bad:**
```javascript
const programmerOutput = [
  {
    name: "Uncle Bobby",
    linesOfCode: 500,
  },
  {
    name: "Suzie Q",
    linesOfCode: 1500,
  },
  {
    name: "Jimmy Gosling",
    linesOfCode: 150,
  },
  {
    name: "Gracie Hopper",
    linesOfCode: 1000,
  },
];

let totalOutput = 0;

for (let i = 0; i < programmerOutput.length; i++) {
  totalOutput += programmerOutput[i].linesOfCode;
}
```

###### ID18

A:: =============================================  
Use functional methods like map, reduce, and filter to write more declarative code. This approach is more concise, easier to read, and less prone to errors.

**Good:**
```javascript
const programmerOutput = [
  {
    name: "Uncle Bobby",
    linesOfCode: 500,
  },
  {
    name: "Suzie Q",
    linesOfCode: 1500,
  },
  {
    name: "Jimmy Gosling",
    linesOfCode: 150,
  },
  {
    name: "Gracie Hopper",
    linesOfCode: 1000,
  },
];

const totalOutput = programmerOutput.reduce((totalLines, output) => totalLines + output.linesOfCode, 0);
```

Q:: =============================================  

##### Encapsulate conditionals

Complex conditional statements can make code harder to read and understand. Extracting conditions into well-named functions improves code readability and reusability.

**Bad:**
```javascript
if (fsm.state === "fetching" && isEmpty(listNode)) {
  // ...
}
```

###### ID19

A:: =============================================  
Create functions with descriptive names that encapsulate the conditional logic. This makes the code self-documenting and easier to maintain.

**Good:**
```javascript
function shouldShowSpinner(fsm, listNode) {
  return fsm.state === "fetching" && isEmpty(listNode);
}

if (shouldShowSpinner(fsmInstance, listNodeInstance)) {
  // ...
}
```

Q:: =============================================  

##### Avoid negative conditionals

Negative conditionals are harder to understand at a glance because they require additional mental processing to understand what the code is not doing rather than what it is doing.

**Bad:**
```javascript
function isDOMNodeNotPresent(node) {
  // ...
}

if (!isDOMNodeNotPresent(node)) {
  // ...
}
```

###### ID20

A:: =============================================  
Use positive conditionals to make code more intuitive and easier to read. This reduces cognitive load and makes the code's intent clearer.

**Good:**
```javascript
function isDOMNodePresent(node) {
  // ...
}

if (isDOMNodePresent(node)) {
  // ...
}
```

Q:: =============================================  

##### Avoid conditionals

Understanding why and how to avoid excessive conditionals is crucial for writing maintainable code. While it may seem impossible to eliminate 'if' statements entirely, polymorphism offers a powerful alternative that better adheres to the Single Responsibility Principle.

Key benefits of avoiding conditionals through polymorphism:
- Better adherence to Single Responsibility Principle
- Easier to test and maintain
- More extensible code
- Clearer class responsibilities

**Bad:**
```javascript
class Airplane {
  // ...
  getCruisingAltitude() {
    switch (this.type) {
      case "777":
        return this.getMaxAltitude() - this.getPassengerCount();
      case "Air Force One":
        return this.getMaxAltitude();
      case "Cessna":
        return this.getMaxAltitude() - this.getFuelExpenditure();
    }
  }
}
```

###### ID21

A:: =============================================  
By using inheritance and polymorphism, we can create specific classes for each airplane type, each implementing its own cruising altitude calculation. This approach makes the code more maintainable and easier to extend with new airplane types.

**Good:**
```javascript
class Airplane {
  // ...
}

class Boeing777 extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude() - this.getPassengerCount();
  }
}

class AirForceOne extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude();
  }
}

class Cessna extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude() - this.getFuelExpenditure();
  }
}
```

Q:: =============================================  

##### Avoid type-checking (part 1)

Type checking in JavaScript often indicates a design that could be improved through better abstraction and consistent interfaces. Instead of checking types, design your objects to support a common interface.

Key principles:
- Use consistent interfaces across related objects
- Leverage polymorphism instead of type checking
- Design for behavior rather than type

**Bad:**
```javascript
function travelToTexas(vehicle) {
  if (vehicle instanceof Bicycle) {
    vehicle.pedal(this.currentLocation, new Location("texas"));
  } else if (vehicle instanceof Car) {
    vehicle.drive(this.currentLocation, new Location("texas"));
  }
}
```

###### ID22

A:: =============================================  
By implementing a common interface (move) across all vehicle types, we eliminate the need for type checking and create more maintainable, flexible code.

**Good:**
```javascript
function travelToTexas(vehicle) {
  vehicle.move(this.currentLocation, new Location("texas"));
}
```

Q:: =============================================  

##### Avoid type-checking (part 2)

Type checking in JavaScript using primitive types often leads to overly complex and hard-to-maintain code. While type safety is important, manual type checking in JavaScript isn't the best approach. TypeScript provides a more robust solution by adding static typing capabilities.

Key benefits of using TypeScript over manual type checking:
- Static type checking at compile time
- Better IDE support and tooling
- Cleaner, more readable code
- Reduced runtime errors

**Bad:**
```javascript
function combine(val1, val2) {
  if (
    (typeof val1 === "number" && typeof val2 === "number") ||
    (typeof val1 === "string" && typeof val2 === "string")
  ) {
    return val1 + val2;
  }

  throw new Error("Must be of type String or Number");
}
```

###### ID23

A:: =============================================  
Instead of complex type checking logic, either use TypeScript for proper type safety or rely on JavaScript's dynamic nature with good testing practices. This makes the code more maintainable and easier to understand.

**Good:**
```javascript
function combine(val1, val2) {
  return val1 + val2;
}

// Or better, using TypeScript:
/*
function combine(val1: string | number, val2: string | number): string | number {
  return val1 + val2;
}
*/
```

Q:: =============================================  

##### Don't over-optimize

Premature optimization can lead to harder-to-maintain code without providing meaningful performance benefits. Modern JavaScript engines are highly sophisticated and handle many optimizations automatically.

Key principles:
- Trust the JavaScript engine's built-in optimizations
- Focus on writing clear, maintainable code first
- Only optimize after profiling identifies actual bottlenecks
- Consider browser compatibility when optimizing

**Reference**:

* [https://github.com/petkaantonov/bluebird/wiki/Optimization-killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)

**Bad:**
```javascript
// On old browsers, each iteration with uncached `list.length` would be costly
// because of `list.length` recomputation. In modern browsers, this is optimized.
for (let i = 0, len = list.length; i < len; i++) {
  // ...
}
```

###### ID24

A:: =============================================  
Write clean, straightforward code and let the JavaScript engine handle optimizations. Modern browsers are smart enough to optimize common operations efficiently.

**Good:**
```javascript
for (let i = 0; i < list.length; i++) {
  // ...
}
```

Q:: =============================================  

##### Remove dead code

Dead code is code that's no longer used but remains in the codebase. It creates confusion, increases maintenance burden, and can lead to bugs. Version control systems like Git already maintain your code history, making it safe to remove unused code.

Key reasons to remove dead code:
- Reduces cognitive load when reading code
- Decreases maintenance burden
- Prevents confusion about which code path is actually used
- Makes the codebase smaller and more manageable

**Bad:**
```javascript
function oldRequestModule(url) {
  // ...
}

function newRequestModule(url) {
  // ...
}

const req = newRequestModule;
inventoryTracker("apples", req, "www.inventory-awesome.io");
```

###### ID25

A:: =============================================  
Keep only the code that's actively being used. If you need to reference old code later, you can always find it in your version control history.

**Good:**
```javascript
function newRequestModule(url) {
  // ...
}

const req = newRequestModule;
inventoryTracker("apples", req, "www.inventory-awesome.io");
```

#### Chapter 3 - **Objects and Data Structures**

Q:: =============================================  

##### Use getters and setters

Getters and setters provide a way to control access to object properties, enabling better encapsulation and more flexible property management. They allow you to add validation, logging, or other behaviors without changing the interface.

Key benefits of getters and setters:
- Enhanced encapsulation
- Ability to add validation logic
- Easy to implement computed properties
- Facilitates logging and debugging
- Enables lazy loading of properties

**Bad:**
```javascript
function makeBankAccount() {
  // ...

  return {
    balance: 0,
    // ...
  };
}

const account = makeBankAccount();
account.balance = 100;
```

###### ID26

A:: =============================================  
Using getters and setters provides better control over property access and modification, allowing for validation, logging, and other behaviors to be added without changing the interface.

**Good:**
```javascript
function makeBankAccount() {
  let balance = 0; // private variable

  // a "getter", made public via the returned object below
  function getBalance() {
    // Add logging if needed
    console.log('Balance accessed');
    return balance;
  }

  // a "setter", made public via the returned object below
  function setBalance(amount) {
    // Validate before updating
    if (amount < 0) {
      throw new Error('Balance cannot be negative');
    }
    balance = amount;
  }

  return {
    // ...
    getBalance,
    setBalance,
  };
}

const account = makeBankAccount();
account.setBalance(100);
```

Q:: =============================================  

##### Make objects have private members

Privacy in objects helps maintain encapsulation and prevents unauthorized access to internal state. While JavaScript didn't have built-in privacy features before ES2019, we can achieve privacy through closures.

Key benefits of private members:
- Better encapsulation
- Controlled access to internal state
- Reduced risk of name collisions
- Clearer interfaces
- Easier refactoring

**Bad:**
```javascript
const Employee = function(name) {
  this.name = name;
};

Employee.prototype.getName = function getName() {
  return this.name;
};

const employee = new Employee("John Doe");
console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe
delete employee.name;
console.log(`Employee name: ${employee.getName()}`); // Employee name: undefined
```

###### ID27

A:: =============================================  
Using closures to create private members provides true privacy and prevents external modification of internal state.

**Good:**
```javascript
function makeEmployee(name) {
  // 'name' is private due to closure
  return {
    getName() {
      return name;
    },
  };
}

const employee = makeEmployee("John Doe");
console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe
delete employee.name; // Has no effect
console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe
```

#### Chapter 4 - **Classes**

Q:: =============================================  

##### Prefer ES2015/ES6 classes over ES5 plain functions

ES2015/ES6 classes provide a clearer, more intuitive syntax for object-oriented programming in JavaScript compared to the ES5 prototype-based approach. They make inheritance patterns more readable and reduce boilerplate code.

Key benefits of ES6 classes:
- Clearer syntax for OOP concepts
- Built-in constructor method
- Straightforward inheritance with 'extends'
- Better handling of 'this' binding
- Enhanced readability and maintainability

**Bad:**
```javascript
const Animal = function(age) {
  if (!(this instanceof Animal)) {
    throw new Error("Instantiate Animal with `new`");
  }
  this.age = age;
};

Animal.prototype.move = function move() {};

const Mammal = function(age, furColor) {
  if (!(this instanceof Mammal)) {
    throw new Error("Instantiate Mammal with `new`");
  }
  Animal.call(this, age);
  this.furColor = furColor;
};

Mammal.prototype = Object.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;
Mammal.prototype.liveBirth = function liveBirth() {};

const Human = function (age, furColor, languageSpoken) {
  if (!(this instanceof Human)) {
    throw new Error("Instantiate Human with `new`");
  }

  Mammal.call(this, age, furColor);
  this.languageSpoken = languageSpoken;
};

Human.prototype = Object.create(Mammal.prototype);
Human.prototype.constructor = Human;
Human.prototype.speak = function speak() {};
```

###### ID28

A:: =============================================  
ES6 classes provide a much cleaner and more intuitive way to implement object-oriented patterns in JavaScript.

**Good:**
```javascript
class Animal {
  constructor(age) {
    this.age = age;
  }

  move() {
    /* ... */
  }
}

class Mammal extends Animal {
  constructor(age, furColor) {
    super(age);
    this.furColor = furColor;
  }

  liveBirth() {
    /* ... */
  }
}

class Human extends Mammal {
  constructor(age, furColor, languageSpoken) {
    super(age, furColor);
    this.languageSpoken = languageSpoken;
  }

  speak() {
    /* ... */
  }
}
```

Q:: =============================================  

##### Use method chaining

Method chaining is a pattern that allows multiple methods to be called in a single statement, making code more fluent and expressive. This pattern is commonly seen in libraries like jQuery and Lodash.

Key benefits of method chaining:
- More readable and expressive code
- Reduced variable declarations
- Fluent interface
- Compact syntax
- Better code flow

**Bad:**
```javascript
class Car {
  constructor(make, model, color) {
    this.make = make;
    this.model = model;
    this.color = color;
  }

  setMake(make) {
    this.make = make;
  }

  setModel(model) {
    this.model = model;
  }

  setColor(color) {
    this.color = color;
  }

  save() {
    console.log(this.make, this.model, this.color);
  }
}

const car = new Car("Ford", "F-150", "red");
car.setColor("pink");
car.save();
```

###### ID29

A:: =============================================  
Method chaining creates a more fluent interface by returning 'this' from each method, allowing multiple operations to be chained together.

**Good:**
```javascript
class Car {
  constructor(make, model, color) {
    this.make = make;
    this.model = model;
    this.color = color;
  }

  setMake(make) {
    this.make = make;
    return this; // Enable chaining
  }

  setModel(model) {
    this.model = model;
    return this; // Enable chaining
  }

  setColor(color) {
    this.color = color;
    return this; // Enable chaining
  }

  save() {
    console.log(this.make, this.model, this.color);
    return this; // Enable chaining
  }
}

const car = new Car("Ford", "F-150", "red")
  .setColor("pink")
  .save();
```

Q:: =============================================  

##### Prefer composition to inheritance

Composition and inheritance are two fundamental approaches to code reuse in object-oriented programming. While inheritance is powerful, composition often provides more flexibility and looser coupling between components.

Key reasons to prefer composition:
- More flexible design
- Avoids deep inheritance hierarchies
- Easier to change behavior at runtime
- Better encapsulation
- Reduces coupling between classes

When to use inheritance:
1. Clear "is-a" relationships exist
2. Base class behavior can be reused
3. You need to make global changes across all derived classes

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#prefer-composition-over-inheritance](https://github.com/ryanmcdermott/clean-code-javascript#prefer-composition-over-inheritance)

**Bad:**
```javascript
class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // ...
}

// Bad because Employees "have" tax data, they aren't a type of tax data
class EmployeeTaxData extends Employee {
  constructor(ssn, salary) {
    super();
    this.ssn = ssn;
    this.salary = salary;
  }

  // ...
}
```

###### ID30

A:: =============================================  
Use composition to represent "has-a" relationships and inheritance for true "is-a" relationships. This creates more flexible and maintainable code.

**Good:**
```javascript
class EmployeeTaxData {
  constructor(ssn, salary) {
    this.ssn = ssn;
    this.salary = salary;
  }

  // ...
}

class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  setTaxData(ssn, salary) {
    this.taxData = new EmployeeTaxData(ssn, salary);
  }
  // ...
}
```

This approach clearly shows that an Employee has tax data rather than incorrectly modeling it as a type of Employee.

#### Chapter 5 - **SOLID**

Q:: =============================================  

##### Single Responsibility Principle (SRP)

The Single Responsibility Principle states that a class should have only one reason to change. This means each class should focus on doing one specific thing well, rather than trying to handle multiple responsibilities. This makes code more maintainable, testable, and easier to understand.

**Bad:**
```javascript
class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

  verifyCredentials() {
    // ...
  }
}
```

###### ID31

A:: =============================================  
By separating authentication from settings management, we create two classes that each have a single responsibility. This makes the code more modular and easier to modify without affecting other functionality.

**Good:**
```javascript
class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
    // ...
  }
}

class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}
```

Q:: =============================================  

##### Open/Closed Principle (OCP)

The Open/Closed Principle states that software entities should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code, typically achieved through inheritance and polymorphism.

**Bad:**
```javascript
class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = "ajaxAdapter";
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = "nodeAdapter";
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    if (this.adapter.name === "ajaxAdapter") {
      return makeAjaxCall(url).then((response) => {
        // transform response and return
      });
    } else if (this.adapter.name === "nodeAdapter") {
      return makeHttpCall(url).then((response) => {
        // transform response and return
      });
    }
  }
}

function makeAjaxCall(url) {
  // request and return promise
}

function makeHttpCall(url) {
  // request and return promise
}
```

###### ID32

A:: =============================================  
The improved version demonstrates OCP by allowing new adapters to be added without modifying the HttpRequester class. Each adapter implements a common interface (the request method), making the system extensible.

**Good:**
```javascript
class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = "ajaxAdapter";
  }

  request(url) {
    // request and return promise
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = "nodeAdapter";
  }

  request(url) {
    // request and return promise
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    return this.adapter.request(url).then((response) => {
      // transform response and return
    });
  }
}
```

Q:: =============================================  

##### Liskov Substitution Principle (LSP)

The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of its subclasses without breaking the application. In simpler terms, child classes must be able to do everything their parent class can do.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#liskov-substitution-principle-lsp](https://github.com/ryanmcdermott/clean-code-javascript#liskov-substitution-principle-lsp)

**Bad:**
```javascript
class Rectangle {
  constructor() {
    this.width = 0;
    this.height = 0;
  }

  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
    this.height = width;
  }

  setHeight(height) {
    this.width = height;
    this.height = height;
  }
}

// This breaks LSP because Square doesn't behave like a Rectangle
function renderLargeRectangles(rectangles) {
  rectangles.forEach((rectangle) => {
    rectangle.setWidth(4);
    rectangle.setHeight(5);
    const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20.
    rectangle.render(area);
  });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);
```

###### ID33

A:: =============================================  
The solution creates a proper hierarchy where each shape handles its own properties correctly through a common interface. This respects LSP because each shape can be used interchangeably when calculating and rendering areas.

**Good:**
```javascript
class Shape {
  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.forEach((shape) => {
    const area = shape.getArea();
    shape.render(area);
  });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);
```

Q:: =============================================  

##### Interface Segregation Principle (ISP)

The Interface Segregation Principle states that clients should not be forced to depend on interfaces they don't use. In JavaScript, where interfaces are implicit, this means classes shouldn't be forced to implement methods they don't need.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#interface-segregation-principle-isp](https://github.com/ryanmcdermott/clean-code-javascript#interface-segregation-principle-isp)

**Bad:**
```javascript
class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.settings.animationModule.setup();
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName("body"),
  animationModule() {}, // Forced to provide animation module even if not needed
  // ...
});
```

###### ID34

A:: =============================================  
The improved version makes the animation module optional through a separate options object, following ISP by not forcing clients to implement unnecessary functionality.

**Good:**
```javascript
class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.options = settings.options;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.setupOptions();
  }

  setupOptions() {
    if (this.options.animationModule) {
      // ...
    }
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName("body"),
  options: {
    animationModule() {},
  },
});
```

Q:: =============================================  

##### Dependency Inversion Principle (DIP)

The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. This promotes loose coupling and makes the code more flexible and easier to modify.

**Reference**:

* [https://github.com/ryanmcdermott/clean-code-javascript#dependency-inversion-principle-dip](https://github.com/ryanmcdermott/clean-code-javascript#dependency-inversion-principle-dip)

**Bad:**
```javascript
class InventoryRequester {
  constructor() {
    this.REQ_METHODS = ["HTTP"];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryTracker {
  constructor(items) {
    this.items = items;
    // Bad: Directly creating an instance of a specific requester
    this.requester = new InventoryRequester();
  }

  requestItems() {
    this.items.forEach((item) => {
      this.requester.requestItem(item);
    });
  }
}

const inventoryTracker = new InventoryTracker(["apples", "bananas"]);
inventoryTracker.requestItems();
```

###### ID35

A:: =============================================  
The improved version implements DIP by:

1. Injecting the requester dependency

2. Allowing different types of requesters to be used

3. Making the high-level module (InventoryTracker) independent of specific implementations

**Good:**
```javascript
class InventoryTracker {
  constructor(items, requester) {
    this.items = items;
    this.requester = requester;
  }

  requestItems() {
    this.items.forEach((item) => {
      this.requester.requestItem(item);
    });
  }
}

class InventoryRequesterV1 {
  constructor() {
    this.REQ_METHODS = ["HTTP"];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryRequesterV2 {
  constructor() {
    this.REQ_METHODS = ["WS"];
  }

  requestItem(item) {
    // ...
  }
}

// We can easily switch between different requesters
const inventoryTracker = new InventoryTracker(
  ["apples", "bananas"], 
  new InventoryRequesterV2()
);
```

#### Chapter 6 - **Testing**

Testing is more important than shipping. If you have no tests or an inadequate amount, then every time you ship code you won't be sure that you didn't break anything. Deciding on what constitutes an adequate amount is up to your team, but having 100% coverage (all statements and branches) is how you achieve very high confidence and developer peace of mind. This means that in addition to having a great testing framework, you also need to use a [good coverage tool](https://gotwarlost.github.io/istanbul/).

There's no excuse to not write tests. There are [plenty of good JS test frameworks](https://jstherightway.org/#testing-tools), so find one that your team prefers. When you find one that works for your team, then aim to always write tests for every new feature/module you introduce. If your preferred method is Test Driven Development (TDD), that is great, but the main point is to just make sure you are reaching your coverage goals before launching any feature, or refactoring an existing one.

Q:: =============================================  

##### Single concept per test

Tests should be clear, focused, and test one specific concept or behavior. This makes tests easier to maintain, debug, and understand when they fail. Each test should tell a story about a specific behavior of your code.

**Bad:**
```javascript
import assert from "assert";

describe("MomentJS", () => {
  it("handles date boundaries", () => {
    let date;

    date = new MomentJS("1/1/2015");
    date.addDays(30);
    assert.equal("1/31/2015", date);

    date = new MomentJS("2/1/2016");
    date.addDays(28);
    assert.equal("02/29/2016", date);

    date = new MomentJS("2/1/2015");
    date.addDays(28);
    assert.equal("03/01/2015", date);
  });
});
```

###### ID36

A:: =============================================  
By splitting the tests into separate cases, we make it clear what functionality is being tested and make it easier to identify which specific behavior has failed. Each test has a descriptive name that explains the exact scenario being tested.

**Good:**
```javascript
import assert from "assert";

describe("MomentJS", () => {
  it("handles 30-day months", () => {
    const date = new MomentJS("1/1/2015");
    date.addDays(30);
    assert.equal("1/31/2015", date);
  });

  it("handles leap year", () => {
    const date = new MomentJS("2/1/2016");
    date.addDays(28);
    assert.equal("02/29/2016", date);
  });

  it("handles non-leap year", () => {
    const date = new MomentJS("2/1/2015");
    date.addDays(28);
    assert.equal("03/01/2015", date);
  });
});
```

#### Chapter 7 - **Concurrency**

Q:: =============================================  

##### Use Promises, not callbacks

Promises provide a cleaner way to handle asynchronous operations compared to callbacks. They help avoid "callback hell" (deeply nested callbacks) and provide better error handling mechanisms. Promises make asynchronous code more readable and maintainable.

**Bad:**
```javascript
import { get } from "request";
import { writeFile } from "fs";

get("https://en.wikipedia.org/wiki/Robert_Cecil_Martin", (requestErr, response, body) => {
  if (requestErr) {
    console.error(requestErr);
  } else {
    writeFile("article.html", body, (writeErr) => {
      if (writeErr) {
        console.error(writeErr);
      } else {
        console.log("File written");
      }
    });
  }
});
```

###### ID37

A:: =============================================  
Using Promises creates a flat chain of operations that's easier to read and maintain. Error handling is consolidated into a single .catch() block, making the code more concise and clearer.

**Good:**
```javascript
import { get } from "request-promise";
import { writeFile } from "fs-extra";

get("https://en.wikipedia.org/wiki/Robert_Cecil_Martin")
  .then((body) => {
    return writeFile("article.html", body);
  })
  .then(() => {
    console.log("File written");
  })
  .catch((err) => {
    console.error(err);
  });
```

Q:: =============================================  

##### Async/Await are even cleaner than Promises

Async/await is a modern JavaScript feature that makes asynchronous code look and behave more like synchronous code. It provides the best readability while maintaining all the benefits of Promises, making code easier to understand and maintain.

**Bad:**
```javascript
import { get } from "request-promise";
import { writeFile } from "fs-extra";

get("https://en.wikipedia.org/wiki/Robert_Cecil_Martin")
  .then((body) => {
    return writeFile("article.html", body);
  })
  .then(() => {
    console.log("File written");
  })
  .catch((err) => {
    console.error(err);
  });
```

###### ID38

A:: =============================================  
Using async/await makes the code read like synchronous code while maintaining asynchronous behavior. The try/catch block provides familiar error handling syntax, making it more intuitive for developers.

**Good:**
```javascript
import { get } from "request-promise";
import { writeFile } from "fs-extra";

async function getCleanCodeArticle() {
  try {
    const body = await get("https://en.wikipedia.org/wiki/Robert_Cecil_Martin");
    await writeFile("article.html", body);
    console.log("File written");
  } catch (err) {
    console.error(err);
  }
}

getCleanCodeArticle();
```

#### Chapter 8 - **Error Handling**

Thrown errors are a good thing! They mean the runtime has successfully identified when something in your program has gone wrong, and it's letting you know by stopping function execution on the current stack, killing the process (in Node), and notifying you in the console with a stack trace.

Q:: =============================================  

##### Don't ignore caught errors

Proper error handling is crucial for maintaining robust applications. Simply catching errors without handling them appropriately can lead to silent failures and make debugging extremely difficult.

**Bad:**
```javascript
try {
  functionThatMightThrow();
} catch (error) {
  console.log(error);
}
```

###### ID39

A:: =============================================  
When catching errors, implement proper error handling strategies that allow for debugging, user notification, and/or error reporting. This helps maintain system reliability and provides better debugging information.

**Good:**
```javascript
try {
  functionThatMightThrow();
} catch (error) {
  // Detailed error logging for debugging
  console.error(error);
  
  // Inform the user in a user-friendly way
  notifyUserOfError(error);
  
  // Track errors in your monitoring system
  reportErrorToService(error);
  // OR do all three!
}
```

Q:: =============================================  

##### Don't ignore rejected promises

Proper handling of Promise rejections is crucial for maintaining robust applications. Just like with try/catch blocks, ignoring Promise rejections can lead to silent failures, making debugging difficult and potentially leaving your application in an inconsistent state.

**Bad:**
```javascript
getdata()
  .then((data) => {
    functionThatMightThrow(data);
  })
  .catch((error) => {
    console.log(error);
  });
```

###### ID40

A:: =============================================  
When handling Promise rejections, implement comprehensive error handling strategies that provide proper logging, user feedback, and error tracking. This creates more maintainable and reliable applications.

**Good:**
```javascript
getdata()
  .then((data) => {
    functionThatMightThrow(data);
  })
  .catch((error) => {
    // Detailed logging for debugging purposes
    console.error(error);
    
    // Provide user-friendly error messages
    notifyUserOfError(error);
    
    // Log to error tracking service for monitoring
    reportErrorToService(error);
    
    // Consider retrying the operation if appropriate
    // retry(operation, retryCount);
  });
```

#### Chapter 9 - **Formatting**

Formatting is subjective. Like many rules herein, there is no hard and fast rule that you must follow. The main point is DO NOT ARGUE over formatting. There are [tons of tools](https://standardjs.com/rules.html) to automate this. Use one! It's a waste of time and money for engineers to argue over formatting.

For things that don't fall under the purview of automatic formatting (indentation, tabs vs. spaces, double vs. single quotes, etc.) look here for some guidance.

Q:: =============================================  

##### Use consistent capitalization

Consistent capitalization serves as a visual cue for the purpose and behavior of code elements in JavaScript. Since JavaScript is untyped, these naming conventions help developers quickly understand the role of different variables, functions, and classes. Following consistent patterns makes code more readable and maintainable.

**Bad:**
```javascript
const DAYS_IN_WEEK = 7;
const daysInMonth = 30;

const songs = ["Back In Black", "Stairway to Heaven", "Hey Jude"];
const Artists = ["ACDC", "Led Zeppelin", "The Beatles"];

function eraseDatabase() {}
function restore_database() {}

class animal {}
class Alpaca {}
```

###### ID41

A:: =============================================  
Following consistent capitalization rules makes code more predictable and easier to read. Here's a common convention:

- Use UPPER_CASE for constants

- Use PascalCase for class names

- Use camelCase for functions and variables

- Avoid mixing different naming conventions for similar elements

**Good:**
```javascript
const DAYS_IN_WEEK = 7;
const DAYS_IN_MONTH = 30;

const SONGS = ["Back In Black", "Stairway to Heaven", "Hey Jude"];
const ARTISTS = ["ACDC", "Led Zeppelin", "The Beatles"];

function eraseDatabase() {}
function restoreDatabase() {}

class Animal {}
class Alpaca {}
```

Q:: =============================================  

##### Function callers and callees should be close

Code organization impacts readability and maintainability. Functions that work together should be located close to each other in the source file. This principle follows natural reading patterns and makes it easier to understand the flow of the program.

**Bad:**
```javascript
class PerformanceReview {
  constructor(employee) {
    this.employee = employee;
  }

  lookupPeers() {
    return db.lookup(this.employee, "peers");
  }

  lookupManager() {
    return db.lookup(this.employee, "manager");
  }

  getPeerReviews() {
    const peers = this.lookupPeers();
    // ...
  }

  perfReview() {
    this.getPeerReviews();
    this.getManagerReview();
    this.getSelfReview();
  }

  getManagerReview() {
    const manager = this.lookupManager();
  }

  getSelfReview() {
    // ...
  }
}

const review = new PerformanceReview(employee);
review.perfReview();
```

###### ID42

A:: =============================================  
Organizing related functions close together improves code readability by:

- Making the code flow more natural to follow

- Reducing the need to jump around the file

- Making relationships between functions more obvious

- Facilitating easier code maintenance and updates

**Good:**
```javascript
class PerformanceReview {
  constructor(employee) {
    this.employee = employee;
  }

  // Main workflow function at the top
  perfReview() {
    this.getPeerReviews();
    this.getManagerReview();
    this.getSelfReview();
  }

  // Grouped related functions together
  getPeerReviews() {
    const peers = this.lookupPeers();
    // ...
  }

  lookupPeers() {
    return db.lookup(this.employee, "peers");
  }

  getManagerReview() {
    const manager = this.lookupManager();
  }

  lookupManager() {
    return db.lookup(this.employee, "manager");
  }

  getSelfReview() {
    // ...
  }
}

const review = new PerformanceReview(employee);
review.perfReview();
```

#### Chapter 10 - **Comments**

Q:: =============================================  

##### Only comment things that have business logic complexity

Comments should explain the "why" behind complex business logic, not the "what" or "how" that should be evident from well-written code. Excessive comments often indicate that the code itself could be clearer or better structured.

**Bad:**
```javascript
function hashIt(data) {
  // The hash
  let hash = 0;
  // Length of string
  const length = data.length;
  // Loop through every character in data
  for (let i = 0; i < length; i++) {
    // Get character code.
    const char = data.charCodeAt(i);
    // Make the hash
    hash = (hash << 5) - hash + char;
    // Convert to 32-bit integer
    hash &= hash;
  }
}
```

###### ID43

A:: =============================================  
The improved version removes redundant comments that simply describe what the code is doing. Only keep comments that explain complex algorithms or business decisions that aren't immediately obvious from the code.

**Good:**
```javascript
function hashIt(data) {
  let hash = 0;
  const length = data.length;
  for (let i = 0; i < length; i++) {
    const char = data.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    // Converting to 32-bit integer is necessary to handle large strings
    // and maintain consistent hash values across different platforms
    hash &= hash;
  }
}
```

Q:: =============================================  

##### Don't leave commented out code in your codebase

Commented-out code creates confusion and clutters the codebase. It raises questions about whether the code is still needed or why it was commented out. Modern version control systems like Git are the proper tools for maintaining code history.

**Bad:**
```javascript
doStuff();
// doOtherStuff();
// doSomeMoreStuff();
// doSoMuchStuff();
```

###### ID44

A:: =============================================  
Keep your codebase clean by removing commented-out code entirely. If you need to refer to old code, you can always find it in your version control history.

**Good:**
```javascript
doStuff();
```

Q:: =============================================  

##### Don't have journal comments

Journal comments that track changes are redundant when using version control systems. They become outdated quickly and add unnecessary noise to the codebase. Modern version control systems provide better tools for tracking changes and their authors.

**Bad:**
```javascript
/**
 * 2016-12-20: Removed monads, didn't understand them (RM)
 * 2016-10-01: Improved using special monads (JP)
 * 2016-02-03: Removed type-checking (LI)
 * 2015-03-14: Added combine with type-checking (JR)
 */
function combine(a, b) {
  return a + b;
}
```

###### ID45

A:: =============================================  
Instead of maintaining a manual change log in comments, use version control commands like `git log`, `git blame`, and meaningful commit messages to track changes.

**Good:**
```javascript
function combine(a, b) {
  return a + b;
}
```

Q:: =============================================  

##### Avoid positional markers

Positional markers or section dividers add visual noise without providing real value. Well-structured code with meaningful names and proper organization should make the code's structure clear without needing these artificial divisions.

**Bad:**
```javascript
////////////////////////////////////////////////////////////////////////////////
// Scope Model Instantiation
////////////////////////////////////////////////////////////////////////////////
$scope.model = {
  menu: "foo",
  nav: "bar",
};

////////////////////////////////////////////////////////////////////////////////
// Action setup
////////////////////////////////////////////////////////////////////////////////
const actions = function () {
  // ...
};
```

###### ID46

A:: =============================================  
Instead of using visual markers, organize your code into well-named functions and modules. Use proper spacing and meaningful names to create natural visual structure.

**Good:**
```javascript
$scope.model = {
  menu: "foo",
  nav: "bar",
};

const actions = function () {
  // ...
};
```

Best practices for comments:
1. Use comments to explain complex business logic or algorithms
2. Write comments that explain "why" rather than "what"
3. Keep comments up-to-date with code changes
4. Use version control for tracking changes instead of comment-based histories
5. Let well-structured code speak for itself through clear naming and organization

---

DECK INFO

TARGET DECK: Javascript::Coding best practices::RCCJ - Clean code javascript - ryan mcdermott

FILE TAGS: #Javascript::#Coding-best-practices

Tags:

Reference:

Related:

```dataview
where file.name = this.file.name
```
